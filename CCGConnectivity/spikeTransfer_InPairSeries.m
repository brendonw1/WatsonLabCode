function strengths = spikeTransfer_InPairSeries(S,cnxnpairs,funcsynapses,cnxnstarts,cnxnends,raw,byratio)
% Iteratively get a series of spike transmission strengths in a series of 
% pairs of cells (ie cells with Econnections).  Strength will be either %
% of pre-syn spikes that result in post-syn spikes, or under a different
% regime will be the proportion of extra spikes that are greater than
% expected... which one depends on the variable "raw".
% Wrapper of sorts for SpikeTransfer.m.
%
% INPUTS
% S - tsdarray (from TSToolbox) of spike data for a dataset of cells
% cnxnpairs - Pairs of cells on which to measure spike transmission rates
%               [2-column array, each row is a pair, column 1 is pre cells,
%               column 2 is postsynaptic cells]
% funcsynapses - data and metadata around functional synapses, generated by
%                   FindSynapseWrapper
% cnxnstarts- starts of timeranges of interest where transmission should
%               be measured [array of size numcellsxnumcells, where index
%               (pre,post) can access start time for that pre,post pair]
% cnxnends - ends of """ 
% raw      - If raw = 1, a raw proportion of postsyn spikes per presynspike
%            will be computed.  
%          - If raw = 0, spike strength will be
%            calculated as the % (proportion actually) of spikes in excess
%            of expectation (as determined by convolution of the ccg, by
%            Eran Stark's cch_conv.m).  Default = 0;
% 
% OUTPUTS
% strengths = 1D array of proportions of presyn cells correlated by postsyn
%               cells within the specified window, 1 value for each pair given in
%               cnxnpairs
%
% Brendon Watson 2014.

if ~exist('raw','var')
    raw = 0; %if raw = 1
end
if ~exist('byratio','var')
    byratio = 0; %if raw = 1
end

plotting = 1;


% ccg = funcsynapses.fullCCGMtx;

for a=1:size(cnxnpairs,1)
    pre = cnxnpairs(a,1);
    post = cnxnpairs(a,2);

    if cnxnpairs(a,1)<cnxnpairs(a,2)
        cstart = cnxnstarts(pre,post); %start time
        cend = cnxnends(pre,post);%end time
    else%if flipped
        cstart = -cnxnstarts(pre,post); %start time
        cend = -cnxnends(pre,post);%end time
    end
        
%     thresh = funcsynapses.PairUpperThreshs(max([pre post]),min([pre post]));
%     if funcsynapses.CellShanks(pre)==funcsynapses.CellShanks(post)
%         
%     else
    if length(cstart) == length(cend) & ~isempty(cstart)
        if a == 13 %& post ==55
            1;
        end
        
        if raw
            strengths(a) = SpikeTransfer(TimePoints(S{pre}),TimePoints(S{post}),funcsynapses.BinMs,sort([cstart cend]));
        else
            sameshank = funcsynapses.CellShanks(pre) == funcsynapses.CellShanks(post);
            HalfCCGWidthinms = (size(funcsynapses.fullCCGMtx,1)-1)/2*funcsynapses.BinMs;
            ConvWidth = funcsynapses.ConvolutionWidthInBins;
            BinMs = funcsynapses.BinMs;
            [strengthbyratio(a), strengthbyratechg(a)] = SpikeTransfer_Norm2(TimePoints(S{pre}),TimePoints(S{post}),BinMs,HalfCCGWidthinms,sort([cstart cend]),ConvWidth,sameshank);
        end
%         figure;bar(funcsynapses.CCGbins,ccg(:,pre,post))
%         hold on;plot(cnxntimes,[mean(ccg(:,pre,post)) mean(ccg(:,pre,post))],'m','LineWidth',5)
    end
    if plotting
        PlotCcgFromS(S,pre,post)
        title([num2str(pre) ' ' num2str(post)])
    end
end

% correcting so no errors if there were no calc'd strengths
if ~exist('strengths','var')
    strengths = [];
end
if ~exist('strengthbyratio','var')
    strengthbyratio = [];
end
if ~exist('strengthbyratechg','var')
    strengthbyratechg = [];
end

%funnelling all output into "strengths" variable, for now...
if ~raw
    if byratio && exist('strengthbyratio','var')
        strengths = strengthbyratio;
    elseif exist('strengthbyratechg','var')
        strengths = strengthbyratechg;
    else
        strengths = [];
    end
end

